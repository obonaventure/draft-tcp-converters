---
title: TCP Converter: An Application 0-RTT Proxy
abbrev: 
docname: draft-bonaventure-mptcp-converters-01
date: 2017-07-17
category: exp

ipr: trust200902
area: Transport
workgroup: MPTCP Working Group
keyword: Internet-Draft

coding: us-ascii 
stand_alone: yes
pi: [toc, sortrefs, symrefs]

author:
 -
  ins: O. Bonaventure
  name: Olivier Bonaventure
  organization: Tessares
  email: Olivier.Bonaventure@tessares.net
 -
  ins: M. Boucadair
  name: Mohamed Boucadair
  organization: Orange
  email: mohamed.boucadair@orange.com
 -
  ins: B. Peirens
  name: Bart Peirens
  organization: Proxiums
  email: bart.peirens@proximus.com

normative:
  RFC0793:
  RFC4291:
  RFC6824:
  RFC7413:

informative:
  RFC1928:
  RFC3135:
  RFC6555:
  RFC7414:
  RFC6887:
  I-D.ietf-tcpinc-tcpcrypt:
  I-D.olteanu-intarea-socks-6:
  I-D.boucadair-mptcp-plain-mode:
  I-D.peirens-mptcp-transparent:
  I-D.arkko-arch-low-latency:
  Fukuda2011:
    author:
      - ins: K. Fukuda
    title: An Analysis of Longitudinal TCP Passive Measurements (Short Paper)
    seriesinfo: Traffic Monitoring and Analysis. TMA 2011. Lecture Notes in Computer Science, vol 6613.
    date: 2011
  IMC11:
    author: 
      - ins: K. Honda
      - ins: Y. Nishida
      - ins: C. Raiciu
      - ins: A. Greenhalgh
      - ins: M. Handley
      - ins: T. Hideyuki
    title: Is it still possible to extend TCP ?
    seriesinfo: Proceedings of the 2011 ACM SIGCOMM conference on Internet measurement conference
    date: 2011 
  IETFJ16:
    author:
      - ins: O. Bonaventure
      - ins: S. Seo
    title: Multipath TCP Deployment
    seriesinfo: IETF Journal, Fall 2016
  HotMiddlebox13b:
    title: Multipath in the Middle(Box)
    author:
      - ins: G. Detal
      - ins: C. Paasch
      - ins: O. Bonaventure
    seriesinfo: HotMiddlebox'13
    date: Dec. 2013
    target: http://inl.info.ucl.ac.be/publications/multipath-middlebox
                   
--- abstract

This document specifies an application proxy, called Transport Converter, to
assist the deployment of TCP extensions such as Multipath TCP. This proxy is designed to avoid inducing extra delay when involved in a network-assisted connecton (that is, 0-RTT).
This specification assumes an explicit model, where the proxy is explicitely configured to hosts.

--- middle

# Introduction  {#intro}

Transport protocols like TCP evolve regularly {{RFC7414}}. Given the end-to-end nature of those protocols, 
a new feature can only be used once it has been deployed on both clients and servers. 
Experience with TCP extensions reveals that the deployment of a new TCP extension 
requires many years {{Fukuda2011}}. 

There are some situations where the transport stack used on clients (resp. servers) 
can be upgraded at a faster pace than the transport stack running on servers (resp. 
clients). In those situations, clients would typically want to benefit from the 
features of an improved transport protocol even if the servers have not yet been 
upgraded and conversely. In the past, Performance Enhancing Proxies have been 
proposed and deployed {{RFC3135}} as solutions to improve TCP performance over 
links with specific characteristics. 

Recent examples of TCP extensions include Multipath TCP 
{{RFC6824}} or TCPINC {{I-D.ietf-tcpinc-tcpcrypt}}. Those extensions
provide features that are interesting for clients such as cellular devices. 
With Multipath TCP, cellular devices could seamlessly use WLAN and cellular networks, 
either for bonding purposes, for faster handovers, or better resiliency. 
Unfortunately, deploying those extensions on both a wide range of clients and 
servers remains difficult.

This document specifies an application proxy, called Transport Converter. A
Transport Converter is a function that is installed by a network
operator to aid the deployment of TCP extensions and to provide the benefits of such extensions to the subscribers.  A Transport Converter
operates entirely at the transport layer and supports one or more TCP extensions. The converter protocol is an application layer protocol 
that uses a TCP port number (see IANA section). The Transport Converter adheres to the main principles as drawn in {{RFC1919}}. In particular, the Converter achieves the following: 

- Listen for client sessions;
- Receive from a client the address of the final target server;
- Setup a session to the final server;
- Relay control messages and data between the client and the server;
- Perform access controls according to local policies.


The main advantage of network-assisted converters is that they enable new TCP extensions to be used on 
a subset of the end-to-end path, which encourages the deployment of these extensions. A Transport Converter is designed to not alter options that are supplied by the client or the server; those options can still be negotiated directly between the endpoints.    

This document does not assume that all the traffic is eligible to the network-assisted conversion service. Only a subset of the trafic will be forwarded to a converter according to a set of policies. Furthermore, it is possible to bypass the converter to connect to the servers that already support the required TCP extension.

This document assumes that a client is configured with one or a list of transport converters. Configuration means are outside the scope of this document. 

This document is organised as follows. We first provide a brief explanation of the
operation of Transport Converters in {{sec-arch}}. We compare them in
{{sec-socks}} with SOCKS proxies that are already used to deploy
Multipath TCP in cellular networks {{IETFJ16}}. We then describe the Converter
protocol in {{sec-protocol}} and illustrate its usage with a few examples
in {{sec-examples}}. We then discuss the interactions with middleboxes
({{sec-middleboxes}}) and the security considerations ({{sec-security}}).

# Architecture {#sec-arch}

The architecture considers three types of end hosts:

- Client endhosts;
- Transport Converters;
- Server endhosts.

It does not mandate anything on the server side. The architecture assumes that
new software will be installed on the Client hosts and on Transport Converters. 
Further, the architecture allows for making use of new extensions if those are supported by a given server. 

A Transport Converter is a network function that relays all data exchanged over one
upstream connection to one downstream connection and vice versa. A connection can be initiated from both interfaces of the transport converter (Internet-facing interface, client-facing interface). The 
converter, thus, maintains state that associates one upstream connection to
a corresponding downstream connection. One of the benefits of this design 
is that different transport protocol extensions can be used on the upstream
and the downstream connection. This encourages the deployment of new TCP extensions 
until they are supported by all servers.

~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     +------------+
   <--- upstream --->| transport  |<--- downstream --->
                     | converter  |
                     +------------+   

~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #figtc title="A Transport Converter relays data between pairs of transport connections"}


Transport converters can be operated by either the network operator or 
third parties.  The Client is configured, through means that are outside the 
scope of this document, 
with the names and/or the addresses of one or more Transport Converters. The 
packets belonging to a transport connection that pass through a transport 
converter 
may follow a different path than the packets directly exchanged 
between
the Client and the Server. Deployments should minimise the related possible additional delay 
by carefully selecting the location of the Transport Converter used to reach 
a given destination. 

A transport converter can be embedded in a standalone device or be activated as a service on a router. How such function is enabled is deployement-specific. 

~~~~~~~~~~~~~~~~~~~~~~~~~~~

              +-+    +-+    +-+
    Client -  |R| -- |R| -- |R| - - -  Server
              +-+    +-+    +-+
                      |
                  Transport
                  Converter

~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #figtc2 title="A Transport Converter can be installed anywhere in the network"}

When establishing a transport connection, the Client can, depending on local policies, 
either contact the Server directly (e.g., by sending a TCP SYN towards the Server)
or create the connection via a Transport Converter. In the latter case, which is the case we consider in the following of this document, the Client
initiates a connection towards the Transport Converter and indicates the address and port number of 
the ultimate Server inside the connection establishment packet (shown between brackets
in {{fig-estab}}). Doing so enables the Transport Converter to immediately initiate 
a connection towards that Server, without experiencing an extra delay. The Transport Converter waits until the 
confirmation that the Server agrees to establish the connection, before confirming 
it to the Client. {{fig-estab}} illustrates the 
establishment of a TCP connection by the Client through a Transport Converter. The
information shown between brackets is part of the Converter protocol 
described later in this document.

The connection can also be established from the Internet towards a client via a transport converter. This is typically the case when the client embeds a server (video server, for example). 

~~~~~~~~~~~~~~~~~~~~~~~~~~~
                         Transport
Client                   Converter                       Server
     -------------------->
      SYN [->Server:port]

                                 -------------------->
                                          SYN

                                 <--------------------
                                         SYN+ACK
     <--------------------
       SYN+ACK [ ]

     -------------------->
            ACK
                                 -------------------->
                                          ACK

~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #fig-estab title="Establishment of a TCP connection through a Converter"}

As shown in {{fig-estab}}, the Client and the Converter place its supplied information 
inside the handshake packets between them. This information is encoded in a way that separates 
this information from the user data that can also be carried inside the payload
of such packets (e.g., {{RFC7413}}). 

With TCP, the Converter protocol (running in the Client) places the
destination address and port number of the final Server in the payload of the SYN. 
The SYN+ACK packet returned by the Transport Converter to the Client contains
information that confirms the establishment of the connection between the Transport 
Converter and the final Server. It is important to note that the Transport Converter 
maintains two transport connections that are combined together. The upstream 
connection is the one between the Client and the Transport Converter. The 
downstream connection is between the Transport Converter and the final Server. 

Any user data received by the Transport Converter over the upstream (resp. downstream) 
connection is relayed over the downstream (resp. upstream) connection to give 
to the Client the illusion of an end-to-end connection.

As an example, let us consider how such a protocol can help the deployment of 
Multipath TCP {{RFC6824}}. We assume that both the Client and the Transport 
Converter support Multipath TCP, but consider two different cases depending  
whether the Server supports Multipath TCP or not. A Multipath TCP connection is created
by placing the MP\_CAPABLE (MPC) option in the SYN sent by the Client. 
{{fig-mpestab}} describes the operation of the Transport Converter 
if the Server does not support Multipath TCP, and the Client is aware of the Transport Converter and places the Server:port information in the SYN.

~~~~~~~~~~~~~~~~~~~~~~~~~~~
                         Transport
Client                   Converter                    Server
     -------------------->
     SYN, MPC [->Server:port]

                                 -------------------->
                                       SYN, MPC

                                 <--------------------
                                         SYN+ACK 
     <--------------------
       SYN+ACK,MPC [ NoMPC ]

     -------------------->
         ACK,MPC
                                 -------------------->
                                          ACK

~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #fig-mpestab title="Establishment of a Multipath TCP connection through a Converter"}

The Client tries to initiate a Multipath TCP connection by sending a SYN with the 
MP\_CAPABLE option (MPC in {{fig-mpestab}}). In this example, the Client is aware of the Transport Converter and  the SYN includes the address and port number 
of the final Server, and the Transport Converter attempts to initiate a Multipath TCP 
connection towards this Server. Since the Server does not support Multipath TCP, it 
replies with a SYN+ACK that does not contain the MP\_CAPABLE option. The Transport 
Converter notes that the connection with the Server does not support Multipath TCP.

{{fig-mpestabok}} considers a Server that supports Multipath TCP. In this case, it 
replies to the SYN sent by the Transport Converter with the MP\_CAPABLE option. 
Upon reception of this SYN+ACK, the Transport Converter confirms the establishment 
of the connection to the Client and indicates in the SYN+ACK packet sent to 
the Client that the Server supports Multipath TCP. With this information, 
the Client has discovered that the Server supports Multipath TCP 
natively. This will enable it to bypass the Transport Converter for the next 
Multipath TCP connection that it will initiate towards this Server or by creating a subflow to the server directly. The one established via the transport converter can be closed. 

~~~~~~~~~~~~~~~~~~~~~~~~~~~                                                 
                         Transport
Client                   Converter                       Server
     -------------------->
     SYN, MPC [->Server:port]

                                 -------------------->
                                       SYN, MPC

                                 <--------------------
                                         SYN+ACK, MPC
     <--------------------
       SYN+ACK, MPC [ MPC supported ]

     -------------------->
         ACK, MPC
                                 -------------------->
                                          ACK, MPC
~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #fig-mpestabok title="Establishment of a Multipath TCP connection through a converter"}

## Differences with SOCKSv5 {#sec-socks}

The description above is a simplified description of the Converter protocol. 
At a first glance, the proposed solution could seem similar to the SOCKS v5 protocol 
{{RFC1928}}. This protocol is used to proxy TCP connections. The Client creates
a connection to a SOCKS proxy, exchanges authentication information and indicates
the destination address and port of the final server. At this point, the SOCKS
proxy creates a connection towards the final server and relays all data between
the two proxied connections. The operation of SOCKS v5 is illustrated in {{fig-socks5}}.


~~~~~~~~~~~~~~~~~~~~~~~~~~~                                                 
                         
Client                     SOCKS Proxy                  Server
     -------------------->
             SYN 
     <--------------------
           SYN+ACK
     -------------------->
             ACK
             
     -------------------->
     Version=5, Auth Methods
     <--------------------
           Method
     -------------------->
         Auth Reuqest (if "No auth" method negotiated)
     <--------------------
         Auth Response
     -------------------->
     Connect Server:Port            -------------------->
                                           SYN

                                    <--------------------
                                         SYN+ACK
     <--------------------
          Succeeded

     -------------------->
            Data1
                                    -------------------->
                                           Data1

                                    <--------------------
                                           Data2
     <--------------------
              Data2
~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #fig-socks5 title="Establishment of a TCP connection through a SOCKS proxy without authentication"}

The Converter protocol proposed in this document also relays data
between an upstream and a downstream connection, but there are important
differences with SOCKS v5. 

A first difference is that the Converter protocol leverages the TFO option {{RFC7413}}
to place all its control information inside the SYN and SYN+ACK packets. This reduces
the connection establishment delay compared to SOCKS that requires two
or more round-trip-times before the establishment of the downstream connection towards
the final destination. In today's Internet, latency is a important metric and 
various protocols have been tuned to reduce their latency {{I-D.arkko-arch-low-latency}}. A recently proposed extension to SOCKS also leverages the TFO
option {{I-D.olteanu-intarea-socks-6}}. 

A second difference is that the Converter protocol takes the TCP extensions
explicitly into account. With the Converter protocol, the Client can learn whether
a given TCP extension is supported by the destination Server. This enables the Client to 
bypass the Transport Converter when the destination supports the required 
TCP extension. Neither SOCKS v5 {{RFC1928}} nor the proposed SOCKS v6 {{I-D.olteanu-intarea-socks-6}}
provide such a feature.

A third difference is that a Transport Converter will only accept the connection
initiated by the Client provided that the downstream connection is accepted by
the Server. If the Server refuses the connection establishment attempt from
the Transport Converter, then the upstream connection from the Client
is rejected as well. This feature is important for applications that check the 
availability of a Server or use the time to connect as a hint on the
selection of a Server {{RFC6555}}. This is illustrated in {{fig-mpestabrst}}.


~~~~~~~~~~~~~~~~~~~~~~~~~~~
                         Transport
Client                   Converter                    Server
     -------------------->
     SYN, MPC [->Server:port]

                                 -------------------->
                                       SYN, MPC

                                 <--------------------
                                         RST
     <--------------------
       RST [ ... ]

~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #fig-mpestabrst title="Failed establishment of a Multipath TCP connection through a converter"}

These differences between SOCKS and the Converter protocol imply that
a Transport Converter cannot be implemented as a regular user-space application
like a SOCKS proxy. A Transport Converter needs to interact with the underlying
TCP implementation more closely than the regular socket APIs used by the SOCKS
proxy.


# The Converter Protocol {#sec-protocol}


We now describe in details the messages that are exchanged between a Client and
a Transport Converter. The Converter Protocol (CP) leverages the TCP Fast Open
extension defined in {{RFC7413}}. 

The Converter Protocol uses a 32 bits long fixed header that is sent
by both the Client and the Transport Converter. This header indicates both
the version of the protocol used and the length of the CP messages. 


## The Fixed Header {#sec-header}


When a Client initiates a connection to a Transport Converter using the Converter
Protocol, it MUST send the fixed-sized header shown in {{fig-header}} as the
first four bytes of the bytestream.

~~~~~~~~~~~~~~~~~~~~~~~~~~~
   +---------------+---------------+-------------------------------+
   |  Version      |  Total Length |          Reserved             |
   +---------------+---------------+-------------------------------+
~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #fig-header title="The fixed-sized header of the Converter protocol"}

The Version is encoded as an 8 bits unsigned integer value. This document specifies
version 1. The Total Length is the number of 32 bits word, including the
header, of the bytestream that are consumed by the Converter protocol messages.
Since Total Length is also an 8 bits unsigned integer, those messages cannot
consume more than 1020 bytes of data. This limits the number of bytes
that a Transport Converter needs to process. A
Total Length of zero is invalid and the connection MUST be reset upon
reception of such a header. The Reserved field MUST be set to zero in this
version of the protocol. 

## Transport Convert TLVs {#sec-tlv}

The Converter protocol uses variable length messages that are encoded using 
a TLV format to simplify the parsing of the messages and leave room to extend
the protocol in the future.
A given TLV can only appear once on a Converter connection. If two or more
copies of the same TLV are exchanged over a Converter connection, the associated
TCP connections MUST be closed.

Five TLVs are defined in this document. They are listed in {{tab-converter-tlv}}.

|------+---------|-----------------------------------------------|
| Type | Length  | Description                                   |
|------+---------|-----------------------------------------------|
|   1  |    1    | Bootstrap TLV                                 | 
|  10  | Variable| Connect TLV                                   |
|  20  | Variable| Extended TCP Header TLV                       |
|  21  | Variable| Supported TCP Options TLV                     |
|  30  | Variable| Error TLV                                     |
|------+---------|-----------------------------------------------|
{: #tab-converter-tlv title="The TLVs used by the Converter protocol"}

### Connect TLV {#sec-connect}

This TLV ({{fig-connect}}) is used to request the establishement of a connection via a Transport Converter. 

The 'Remote Peer Port' and 'Remote Peer IP Address' fields include the destination port number and IP address of the target server for an outgoing connection towards a server located on the Internet. For incoming connections destined to a client serviced via a Converter, these fields convey the source port number and IP address. 

The Remote Peer IP Address MUST be encoded
as an IPv6 address. IPv4 addresses MUST be encoded using the 
IPv4-Mapped IPv6 Address format defined in {{RFC4291}}.

The optional 'TCP Options' field is used to specify how some TCP Options 
are advertised by the Transport Converter
to the final destination of a connection. If this field is not supplied, the Transport 
Converter MUST use the default TCP options that correspond to its local 
policy. 

~~~~~~~~~~~~~~~~~~~~~~~~~~~
   +---------------+---------------+-------------------------------+
   |     Type      |     Length    |      Remote Peer Port         |
   +---------------+---------------+-------------------------------+
   |                                                               |
   |         Remote Peer IP Address (128 bits)                     |
   |                                                               |
   |                                                               |
   +---------------------------------------------------------------+
   |                          TCP Options (Variable)               |
   |                              ...                              |
   +---------------------------------------------------------------+
~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #fig-connect title="The Connect TLV"}

The 'TCP Options' field is a variable length field that carries
a list of TCP Option fields ({{fig-tcpopt}}). Each TCP Option field is encoded as a
block of 2+n bytes where the first byte is the TCP 
Option Type and the second byte is the length of the TCP Option
as specified in {{RFC0793}}. The minimum value for the TCP Option Length is 2. 
The TCP Options that do not include a length subfield, i.e., option types 
0 (EOL) and 1 (NOP) defined in {{RFC0793}} cannot be placed inside the 
TCP Options field of the Connect TLV. The optional Value field 
contains the variable-length part of the TCP option. A length of two 
indicates the absence of the Value field. The TCP Options field 
always ends on a 32 bits boundary after being padded with zeros. 


~~~~~~~~~~~~~~~~~~~~~~~~~~~
   +---------------------------------------------------------------+
   |  TCPOpt type  | TCPOpt Length | Value  (opt)  |  ....         |
   +---------------+---------------+-------------------------------+
   |                             ....                              |
   +---------------------------------------------------------------+
   |                               |         Padded with zeros     |
   +---------------------------------------------------------------+
~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #fig-tcpopt title="The TCP Options field"}


If a Transport Converter receives a Connect TLV with an non-empty TCP Options
field, it shall present those options to the destination
peer in addition to the TCP Options that it would have used according to its local
policies. For the 
TCP Options that are listed without an optional value, the Converter MUST generate its
own value. For the TCP Options that are included in the 'TCP Options' field with
an optional value, it shall copy the entire option for use in the connection with the destination peer. This feature is required to support TCP Fast Open as explained in
{{sec-ex-tfo}}.


### Extended TCP Header TLV {#sec-ext-header}

The Extended TCP Header TLV is used by the Transport Converter to return 
to the Client the extended TCP header that was returned by the Server in the
SYN+ACK packet. This TLV is only present if the Client has sent
a Connect TLV to request the establishment of a connection.

~~~~~~~~~~~~~~~~~~~~~~~~~~~
   +---------------+---------------+-------------------------------+
   |     Type      |     Length    |           Reserved            |
   +---------------+---------------+-------------------------------+
   |               Returned Extended TCP header                    |
   |                              ...                              |
   +---------------------------------------------------------------+
~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #fig-tcpheader title="The Extended TCP Header TLV"}

The Returned Extended TCP header field is a copy of the extended header
that was received in the SYN+ACK by the Transport Converter. The 
Reserved field is set to zero by the transmitter and ignored by the 
receiver. 


### Error TLV {#sec-error}

This optional TLV can be used by the Transport Converter to provide
information about some errors that occurred during the processing
of a request to convert a connection. This TLV will appear after
the Converter header in a RST segment returned by the 
Transport Converter if the error is fatal and prevented the
establishment of the connection. If the error is not fatal and
the connection could be established with the final destination, then
the error TLV will be placed in the SYN/ACK packet. 

~~~~~~~~~~~~~~~~~~~~~~~~~~~
   +---------------+---------------+-------------------------------+
   |     Type      |     Length    |    Error       |  Value       |
   +---------------+---------------+-------------------------------+
~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #fig-error title="The Error TLV"}

The following fatal errors are defined in this document:


 - Unsupported Version (0): The version number indicated in the fixed header of a message received from a peer is not supported. The value field indicates the version supported by the converter. This error message MUST be generated by a Converetr when it receives a request having a version number that it does not support. 
 - Not Authorized (1): This error indicates that the Converter
   refused to create a connection because of a lack of authroization (e.g., administratively prohibited, authorization failure, etc.). The Value field is set to zero. This error message MUST be sent by the Converter when a request cannot be successfuly processed because teh authorization failed. 
 - Connection Reset (2): This error indicates that the final
   destination responded with a RST packet. The Value field is set to zero. 
 - Destination Unreachable (3): This error indicates that an ICMP destination 
   unreachable, port unreachable, or network unreachable were received
   by the  Converter. The Value field contains the Code 
   field of the received ICMP message. This error message MUST be sent by the Converter when it receievs an error message that is bound to a message it relayed previousily. 
 - Malformed Message (4): This error is sent to indicate that the message can not be successfully parsed. The value field must be set to 0. The Converter MUST sent this error if it received a malformed message.  
- Unsupported TLV (5): This error indicates that the Transport
   Converter received an unknown TLV. The Value field is set to the
   type of the unknown TLV. If several unknown TLVs were received, multiple value fields are included; each of them encoloses the type of of an unsupported TLV. The Converter MUST sent this error if it received an unknown TLV.   
  - Malformed TLV (6): This error indicates that the Transport
   Converter received a malformed TLV. The Value field is set to the
   type of the malformed TLV. If several malformed TLVs were received, multiple value fields are included; each of them encoloses the type of of a malfomed TLV. The Converter MUST sent this error if it received a malformed TLV. 
 - Resource Exceeded (7): This error indicates that the Transport Converter does 
   not have enough resources to perform the request. This error MUST be sent by the Converter when it does not have sufficient resources to handle a new connection.  
 - Network Failure (8): This error indicates that the converter is experiencing a network failure to relay the request. The converter MUST sent this error when it experiences issues to relay a connection.


The following non-fatal errors are defined in this document:

 - Unsupported TCP Option (128). A TCP Option that the Client requested to
   advertise to the final Server is not supported by the Transport
   Converter. The Value field is set to the type of the unsupported
   TCP Option. If several unsupported TCP Options were specified in the 
   Connect TLV, only one of them is returned in the Value.


{{tab-error-types}} summarises the different error messages.

+-------+-----------------------------------------------+
| Error | Description                                   |
+-------+-----------------------------------------------+
|   0   | Unsupported Version                           | 
|   1   | Not Authorized                                | 
|   2   | Connection Reset                              |
|   3   | Destination Unreachable                       |
|   4   | Malformed Message                             |
|   5   | Unsupported TLV                               |
|   6   | Malformed TLV                                 |
|   7   | Resource Exceeded                             |
|   8   | Network Failure                               |             
|   128 | Unsupported TCP Option                        |
+-------+-----------------------------------------------+

{: #tab-error-types title="The different error types"}


### The Bootstrap TLV {#sec-bootstrap-tlv}

The Bootstrap TLV is sent by a Client to request the TCP Extensions that are 
supported by a Transport Converter. It is typically sent on the first connection
that a Client establishes with a Transport Converter to learn its
capabilities. The Transport Converter replies with the Supported TCP
Options TLV described in {{sec-supported}}.

~~~~~~~~~~~~~~~~~~~~~~~~~~~
   +---------------+---------------+-------------------------------+
   |     Type      |     Length    |             Zero              |
   +---------------+---------------+-------------------------------+

~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #fig-bootstrap title="The Bootstrap TLV"}

### Supported TCP Options TLV {#sec-supported}

The Supported TCP Options TLV is used by a Converter to announce the 
TCP options that it supports. Each supported TCP Option is encoded
with its TCP option Kind listed in the TCP Parameters registry 
maintained by IANA. TCP option Kinds 0, 1 and 2 defined in 
{{RFC0793}} are supported by all TCP implementations and thus cannot
appear in this list. The list of supported TCP Options is padded with
0 to end on a 32 bits boundary.

~~~~~~~~~~~~~~~~~~~~~~~~~~~
   +---------------+---------------+-------------------------------+
   |     Type      |     Length    |           Reserved            |
   +---------------+---------------+-------------------------------+
   |     Kind #1   |     Kind #2   |           ...                 |
   +---------------+---------------+-------------------------------+   
   /                                                               /
   /                                                               /
   +---------------+---------------+-------------------------------+   
   |                               |     Kind #n    |   Zero       |
   +---------------------------------------------------------------+
~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #fig-supported title="The Supported Options TLV"}



# Examples {#sec-examples}


This section provides some examples of the utilisation of the Transport
Converter. We consider the following
network to illustrate the operation of the Converter protocol.


~~~~~~~~~~~~~~~~~~~~~~~~~~~
Client               Transport                 Server
                     Converter
  @c                     @t                       @s

~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #fig-example title="Simple scenario"}

## Bootstrap {#sec-bootstrap}

The Converter protocol is designed with the ability to leverage on the
utilisation of TCP Fast Open between the
Client and the Transport Converter. To be able to place data inside
the SYN packet that it sends, the Client first needs to obtain a
TFO cookie from the Transport Converter. This is achieved by 
establishing a TCP connection to the Transport Converter without
requesting the establishment of a connection towards a Server. This connection is established immediately when a new Converter is configured to the client.

Note that the Converter may rely on local policies to decide whether it can service a given requesting client. That is, the Convert may not return a cookie for that client.

Also, the Converter may behave in a Cookie-less mode when appropriate means are enforced at the converter and the network in-between to protect against attacks such as spoofing and SYN flood. Under such deployments, the use of TFO is not required.  

To perform the bootstrap operation, the Client sends the following 
SYN packet:

 * source IP address: @c (one of the client's IP addresses)
 * destination IP address: @t
 * TCP Options : MSS, TFO (2 bytes), NOP, NOP
 * Payload : empty

The Converter replies with the following SYN+ACK packet:

 * source IP address: @t
 * destination IP address: @c
 * TCP Options : MSS, TFO (including @tcookie), NOP, NOP
 * Payload : empty

At this point, the Client has learned the TFO cookie (@tcookie) that needs
to be used for subsequent exchanges with this Transport Converter. For the examples
in this section, we assume TFO cookies that contain 4 bytes of information.
Other cookie lengths are possible as per {{RFC7413}}.

The Client sends the third Ack to conclude the three-way handshake. 
It then sends in a Data packet the fixed header and the 
Bootstrap TLV to query the TCP options
that are supported by the Converter. This message spans 8 bytes (4 for the fixed
header and 4 for the Bootstrap TLV). The Converter replies with the converter fixed header 
and a TCP Options TLV that indicates the TCP extensions that it supports.


During the bootstrap phase, the Client may register on the Converter the set of its available IP addresses. Announcing these addresses will help the Converter to place incoming multipath connections to the client.  

The Client needs to recontact the Converter before the expiry of the TFO Cookie to refresh it or obtain a new one.

The TFO-cookie supplied by the Converter is inserted in subsequent messages as part of the Converter TLVs. As such, there is no ambiguity with TFO cookie that is supplied by the Client to the remote Server; this second cookie is enclosed according to the procedure in {{RFC7413}}.


## Multipath TCP {#sec-ex-mptcp}

The MP\_CAPABLE Option defined in {{RFC6824}} 
allows to negotiate the utilisation
of Multipath TCP. Consider a Client that uses the Transport Converter 
to create a connection on port 123 with a Server that
supports {{RFC6824}}.

For this, the Client sends the following SYN packet:

 * source IP address: @c
 * destination IP address: @t
 * TCP Options: MSS, TFO (@t cookie), MP\_CAPABLE(key@c)
 * Payload:
   * Converter Header, Total Length=7 32 bits words
   * Connect:
      * Length=6
      * Port=123
      * Address: @s
      * TCP Options:
           * TCPOpt type: 30 (Multipath TCP)
           * TCPOpt Length: 2 (no value)
           * Padding: zero (2 bytes)

Upon reception of this packet, the Transport Converter creates a SYN
packet and sends it to the destination Server:

 * source IP address: @t
 * destination IP address: @s
 * TCP Options: MSS, MP\_CAPABLE(key@ts)
 * Payload: empty

The Server replies with the following SYN+ACK:

 * source IP address: @s
 * destination IP address: @t
 * TCP Options: MSS, MP\_CAPABLE(key@ts,key@s)
 * Payload: empty

The Transport Converter then confirms the establishment of the
connection to the Client with the following SYN+ACK:

 * source IP address: @t
 * destination IP address: @c
 * TCP Options: MSS, MP\_CAPABLE(key@c,key@tc)
 * Payload:
   * Converter Header, Total Length=8
   * TCP Extended Header TLV:
     * Length=7
     * Value: MSS, MP_CAPABLE(key@ts,key@s)


Upon reception of this packet, the Client has the confirmation that
the Multipath TCP connection has been established through the 
Transport Converter. By parsing the TCP Extended Header TLV, 
it detects that Server @s supports Multipath TCP and will thus be able to
bypass the Transport Converter for future connections towards this Server.

In order to support incoming connections from remote hosts, the client may use PCP {{RFC6887}} to instruct the converter to create dynamic mappings. Those mappings will be used by the converter to intercept an incoming TCP connection destined to the client and convert it into an MPTCP connection. 


~~~~~~~~~~~~~~~~~~~~~~~~~~~
                         Transport
Client                   Converter                  Remote Host
                                <-------------------
                                  SYN

     <-------------------
    SYN, MPC[Remote Host:port]                  

     --------------------->
            SYN+ACK, MPC
                                --------------------->
                                        SYN+ACK

                                <---------------------
                                           ACK
     <-------------------
              ACK, MPC

~~~~~~~~~~~~~~~~~~~~~~~~~~~
{: #fig-inestab title="Establishment of an Incoming TCP Connection through a Converter"}

## TCP Fast Open (TFO) {#sec-ex-tfo}

The TCP Fast Open (TFO) option is defined in {{RFC7413}}. In this section,
we show how a Client can use TFO with a remote Server through a
Transport Converter. We consider two TCP connections to this Server. The
Client has already received the cookie of the Transport Converter (@t cookie).

For the first connection, the Client sends the following SYN packet:

 * source IP address: @c
 * destination IP address: @t
 * TCP Options: MSS, TFO (@t cookie)
 * Payload:
   * Converter Header, Total Length=8
   * Connect:
      * Length=7
      * Port=123
      * Address: @s
      * TCP Options:
           * TCPOpt type: 34 (TFO)
           * TCPOpt Length: 2 (no value)
           * Padding: zero (2 bytes)

The TFO option of the SYN packet contains the cookie chosen by the Transport
Converter. The Transport Converter then issues the following SYN packet towards
the Server:

 * source IP address: @t
 * destination IP address: @s
 * TCP Options: MSS, TFO (empty), NOP, NOP
 * Payload: empty

The Server replies with its own TFO cookie (@s cookie) in the SYN+ACK packet:

 * source IP address: @s
 * destination IP address: @t
 * TCP Options: MSS, TFO (@s cookie)
 * Payload: empty

The Converter confirms the establishment of the TCP connection to the Client
by sending the following SYN+ACK packet:

 * source IP address: @t
 * destination IP address: @c
 * TCP Options: MSS, NOP, NOP
 * Payload: 
   * Converter Header, Total Length=8
   * TCP Extended Header TLV:
     * Length=7
     * Value: MSS, TFO (@s cookie)
   * some data


The Client can extract the Server cookie from the TCP Extended
Header TLV and
initiate future connections to this Server as follows (assuming that
it prefers to establish it via the Transport Converter instead of
contacting directly the final destination).

 * source IP address: @c
 * destination IP address: @t
 * TCP Options: MSS, TFO (@t cookie)
 * Payload:
   * Converter Header, Total Length=4
   * Connect:
      * Length=8
      * Port=123
      * Address: @s
      * TCP Options:
           * TCPOpt type: 34 (TFO)
           * TCPOpt Length: 6 (value is @s cookie) 
           * Padding: zero (2 bytes)

The Transport Converter then initiates the connection towards the
final destination by sending the following SYN packet:

 * source IP address: @t
 * destination IP address: @s
 * TCP Options: MSS, TFO (@s cookie), NOP, NOP
 * Payload: some data

The Server verifies the TFO option and accepts the data in the SYN. It
replies with the following SYN+ACK packet:

 * source IP address: @s
 * destination IP address: @t
 * TCP Options: MSS, NOP, NOP
 * Payload: more data

The Server confirms the establishment of the TCP connection to the Client
by sending the following SYN+ACK packet:

 * source IP address: @t
 * destination IP address: @c
 * TCP Options: MSS, NOP, NOP
 * Payload: 
   * Converter Header, Total Length=3
   * Report:
     * Length=2
     * Value: MSS, NOP, NOP
   * more data

The Client has thus been able to use TFO with a remote Server through
the Transport Converter.


# Interactions with middleboxes {#sec-middleboxes}

The Converter protocol was designed to be used in networks that do not
contain middleboxes that interfere with TCP. We describe in this
section how a Client can detect middlebox interference and stop using
the Transport Converter affected by this interference. 

Internet measurements {{IMC11}} 
have shown that middleboxes can affect the deployment of TCP extensions. 
In this section, we only discuss the middleboxes
that modify SYN and SYN+ACK packets since the Converter protocol places
its messages in such packets. 

Let us first consider a middlebox that removes the TFO Option from the SYN packet.
This interference will be detected by the Client during the boostrap procedure
described in section {{sec-bootstrap}}. A Client should not use a Transport Converter
that does not reply with the TFO option during the Bootstrap.

Consider a middlebox that removes the SYN payload after the bootstrap
procedure. The Client can detect this problem by looking at the 
acknowledgement number field of
the SYN+ACK returned by the Transport Converter. 
The Client should stop to use this 
Transport Converter given the middlebox interference.

As explained in {{RFC7413}}, some carrier-grade NATs can affect the operation of 
TFO if they assign different IP addresses to the same endhost. Such carrier-grade
NATs could affect the operation of the TFO Option used by the Converter protocol. 
See also the discussion in section 7.1 of {{RFC7413}}.


# Security Considerations  {#sec-security}

Given its function and its location in the network, a Transport Converter has
access to the payload of all the packets that it processes. 
As such, it must be protected as a core IP router.

The Converter protocol is intended to be used in managed networks where endhosts
can be identified by their IP address. Thanks to the Bootstrap procedure 
described in section {{sec-bootstrap}}, the Transport Converter can verify that
the Client correctly receives packets sent by the Converter. Stronger authentication
schemes should be defined to use the Converter protocol in more open network environments.

Upon reception of a SYN that contains a valid TFO Cookie and a Connect TLV, the
Transport Converter attempts to establish a TCP connection to a remote Server. There is a
risk of denial of service attack if a Client requests too many connections
in a short period of time. Implementations should limit the number of pending 
connections from a given Client.

Another possible risk is represented by amplification attacks, since a Transport Converter sends
a SYN towards a remote Server upon reception of a SYN from a Client. This could 
lead to amplification attacks if the SYN sent by the Transport Converter were larger
than the SYN received from the Client or if the Transport Converter retransmits the
SYN. To mitigate such attacks, the Transport Converter should first limit the number of 
pending requested for a given Client. It should also avoid sending to remote Servers SYNs 
that are significantly longer than the SYN received from the Client. In practice, 
Transport Converters should not advertise to a Server TCP Options that were not specified
by the Client in the received SYN. Finally, the Transport Converter should only retransmit
a SYN to a Server after having received a retransmitted SYN from the corresponding Client. 


# IANA Considerations

This document requests the allocation of a reserved service name and port
number for the converter protocol at https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml.

This documents specifies version 1 of the Converter protocol. 
Five types of Converter messages are defined:

 -  1: Bootstrap TLV  
 - 10: Connect TLV   
 - 20: Extended TCP Header TLV  
 - 21: Supported TCP Options TLV 
 - 30: Error TLV  

Furthermore, it also defines the following errors:
 -  0: Unsupported Version    
 -  1: ANot Authorized    
 -  2: Connection Reset 
 -  3: Destination Unreachable 
 -  4: Malformed Message
 -  5: Unsupported TLV 
 -  6: Malformed TLV
 -  7: Resource Exceeded  
 -  8: Network Failure   
 -128: Unsupported TCP Option   

Values in the 7-127 range are unassigned. Assigning a value in this range requires a Standards Action as per RFC8126. 

# Acknowledgements

This document builds upon earlier documents that proposed various forms
of Multipath TCP proxies {{I-D.boucadair-mptcp-plain-mode}}, 
{{I-D.peirens-mptcp-transparent}} and {{HotMiddlebox13b}}.

We would like to thank Bart Peirens, Raphael Bauduin and Anand Nandugudi
for their help in preparing this draft. 

Although they could disagree with the contents of the document, 
we would like to thank Joe Touch and Juliusz Chroboczek whose 
comments on the MPTCP mailing list have forced
us to reconsider the design of the solution several times.

From {{I-D.boucadair-mptcp-plain-mode}}:

   Many thanks to Chi Dung Phung, Mingui Zhang, Rao Shoaib, Yoshifumi
   Nishida, and Christoph Paasch for their valuable comments.

   Thanks to Ian Farrer, Mikael Abrahamsson, Alan Ford, Dan Wing, and
   Sri Gundavelli for the fruitful discussions in IETF#95 (Buenos
   Aires).

   Special thanks to Pierrick Seite, Yannick Le Goff, Fred Klamm, and
   Xavier Grall for their inputs.

   Thanks also to Olaf Schleusing, Martin Gysi, Thomas Zasowski, Andreas
   Burkhard, Silka Simmen, Sandro Berger, Michael Melloul, Jean-Yves
   Flahaut, Adrien Desportes, Gregory Detal, Benjamin David, Arun
   Srinivasan, and Raghavendra Mallya for the discussion.

# Contributors

As noted above, this document builds on two previous documents. 

The authors of {{I-D.boucadair-mptcp-plain-mode}} were:
- Mohamed Boucadair
- Christian Jacquenet
- Olivier Bonaventure
- Denis Behaghel
- Stefano Secci
- Wim Henderickx
- Robert Skog
- Suresh Vinapamula
- SungHoon Seo
- Wouter Cloetens
- Ullrich Meyer
- Luis M. Contreras
- Bart Peirens

The authors of {{I-D.peirens-mptcp-transparent}} were:
- Bart Peirens
- Gregory Detal
- Sebastien Barre
- Olivier Bonaventure


